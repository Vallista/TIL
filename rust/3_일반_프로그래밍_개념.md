# 3. 일반 프로그래밍 개념

## 3-1. 변수와 가변성

```rust
let x = 0;
println!("x의 값: {}", x);
x = 10;
println!("x의 값: {}", x);
```

위 코드는 동작하지 않는다.

```rust
let mut x = 0;
println!("x의 값: {}", x);
x = 10;
println!("x의 값: {}", x);
```

`let mut`을 붙여줘야 값을 수정할 수 있다.

`let x = 0`: 변수의 불변성
`let mut x = 0`: 변수의 가변성

Mutation (변이? 가변될 수 있다? 로 해석되는듯)

## 3-1-1. 변수와 상수의 차이점

1. 상수는 mut 키워드를 적용할 수 없다.
2. `const` 타입으로 선언한다.
3. 할당 값을 무조껀 넣어주어야 한다.
4. 반드시 타입을 넣어주어야 한다.
5. 상수는 어떤 범위 내에도 선언할 수 있다.
6. 상수는 상수 표현식을 사용해서 값을 할당해야 한다. 함수 호출의 결과나 기타 런타임 연산으로 얻은 값을 사용 할 수 없다.

```rust
const MAX_POINTS: u32 = 100_000;
```

## 3-1-2. 변수 가리기

```rust
fn main() {
  let x = 5;
  let x = x + 1;
  let x = x * 2;
  println!("x의 값: {}", x);
}
```

let을 이용해 절차적으로 후에 선언된 변수가 위의 변수를 가린다. (shadowed)

### mut 키워드와 다른점

1. let 키워드를 사용할 때 새로운 변수를 선언하는 것이므로 이름은 같지만, 타입은 다른 변수를 사용할 수 있다.

```rust
let spaces = "     "
let spaces = spaces.len()
```

1. 문자열 변수를 원래 다르게 표현해야 했던 것을 (같은 도메인의 것을) 동일한 네이밍으로 사용할 수 있다.
2. 하지만 mut 키워드가 섞여있으면 안된다.

## 3.2. 데이터 타입

1. 러스트의 모든 값은 어떤 타입의 데이터이다.
2. 데이터 타입 = 데이터를 올바르게 처리하기 위한 데이터의 종류를 명시한 것
3. 데이터 타입 = 스칼라 (Scalar) + 컴파운드 (Compound)

러스트는 정적타입 언어이며 컴파일 시점에 모든 변수의 타입이 결정되어야 한다는 뜻.
컴파일러는 타입 추론을 통해 변수에 할당된 값이나 변수의 사용을 보고 실제 타입 예측한다.

여러 타입을 사용할 수 있을 때에는 타입 에노테이션(annotation)을 이용해야 한다.

```rust
let guess: u32 = "42".parse().expect("숫자가 아닙니다");
```

타입을 명시하지 않으면 러스트는 어떤 타입을 사용하는 지 모르기에 더 많은 정보가 필요.

### 3.2.1. 스칼라 타입

스칼라 타입은 하나의 값을 표현. 

- 정수(integer)
- 부동 소수점 숫자(floating point numbers)
- 불리언(Boolean)
- 문자(characters)

네 가지 종류의 스칼라 타입을 정의하고 있음

#### 정수 타입

- 부호 없는 정수: i로 시작
- 부호 있는 정수: u로 시작

**정수 타입**

| 크기  | 부호 있음 | 부호 없음 |
| ----- | :-------: | --------: |
| 8bit  |    i8     |        u8 |
| 16bit |    i16    |       u16 |
| 32bit |    i32    |       u32 |
| 64bit |    i64    |       u64 |
| arch  |   isize   |     usize |

**정수 타입 리터럴**

| 숫자 리터럴   |    예시     |
| ------------- | :---------: |
| Decimal       |   98_222    |
| Hex           |    0xff     |
| Octal         |    0o77     |
| Binary        | 0b1111_0000 |
| Byte (u8전용) |    b'A'     |

러스트의 기본 정수 타입: i32
i32는 일반적으로 가장 빠르고, 64bit 플랫폼에서도 그렇다.
isize, usize 타입은 컬렉션 타입의 인덱스를 참조할 때 쓰인다.


> 정수 오버플로 (integer overflow)
>
> u8 타입 (0~255)를 선언하고 이 변수에 값이 255를 초과하면 정수 오버플로가 일어난다.
> 러스트에서는 디버그 모드로 컴파일하면 정수 오버플로에 대한 검사를 추가하여 프로그램에서 패닉이 안일어나도록 한다.
> 러스트에서 에러가 발생해서 프로그램이 중단되는 현상을 패니킹(panicking)이라고 한다.
> 패닉 = panic! 매크로로 처리할 수 있다.
>
> 러스트는 --release 플래그를 사용하면 용량을 줄이기위해 정수 오버플로 검사를 추가하지 않음
> 오버플로 발생 시 보완을 위한 러스트는 두 개의 래핑을 추가한다.
> 타입의 최댓값보다 큰 값은 타입이 가질 수 있는 가장 작은 값으로 둘려 쌓인다 = 256 -> 0 257 -> 1
> 이렇게 되면 패닉이 일어나진 않지만 의도된 동작이 되진 않는다.
> 값을 명시적으로 래핑하려면 표준 라이브러리의 Wrapping 타입을 사용하면 된다.

#### 부동 소수점 타입

```rust
fn main() {
  let x = 2.0; // f64
  let y: f32 = 3.0; // f32
}
```

- 부동 소수점 숫자는 [IEEE754](https://ko.wikipedia.org/wiki/IEEE_754) 표준으로 표현
- f32 타입: 단정도(single-precision) / f64 타입: 배정도(double-precision)

#### 사칙연산

```rust
fn main() {
  let sum = 5 + 10;

  let difference = 95.5 - 4.3;

  let product = 4 * 30;

  let quotient = 56.7 / 32.2;

  let remainder = 43 % 5;
}
```

#### Boolean 타입

```rust
fn main() {
  let t = true;

  let f: bool = false;
}
```

#### 문자 타입

```rust
fn main() {
  let c = 'z';
  let z = 'z';
  let heart_eyed_cat = '';
}
```

- 러스트의 char는 4byte 크기의 유니코드 스칼라값
- ASCII보다 더 많은 문자 표현 가능.
- 엑센트가 있는 중국어, 일본어, 한국어는 물론 이모지와 zero-width 등 모든 문자 유효

### 3.2.2 컴파운드 타입

튜플(tuple)과 배열(arrays) 두 가지 컴파운드 타입 지정

#### 튜플

















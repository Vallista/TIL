# 시작하기

러스트의 버전과 관련된 도구를 관리하는 명령줄 도구인 **rustup**을 이용해 러스트를 내려받을 것이다.

## 설치

> macOS를 기준으로 설명한다.

```
$ curl https://sh.rustup.rs -sSf | sh
```

설치가 완료되면

```
Rust is installed now.. Great!
```

출력이 된다.

설치 스크립트는 사용자가 터미널을 다시 실행을 할 때 PATH 환경 변수에 자동으로 등록하므로 현재 터미널을 껏다 켜야한다. 이러한 과정이 번거롭다면 아래와 같은 과정을 거친다.

```
$ source $HOME/.cargo/env
```

해당 스크립트는 cargo (패키지 매니저)의 환경을 실행하는 매소드이다.

## 업데이트와 제거

**업데이트**

```
$ rustup update
```

**제거**

```
$ rustup self uninstall
```

## 문제 해결

```
$ rustc --version
```

를 입력하게 되면 버전 번호 및 커밋 해시, 최신의 안정버전을 커밋한 날짜가 출력된다.

출력되지 않으면 제대로 설치가 되지 않은 것 이므로, [러스트 공식 디스코드](https://discord.gg/rust-lang)을 이용하거나 [러스트 사용자 포럼](https://users.rust-lang.org)를 가자.

## 로컬 문서 서버

```
$ rustup doc
```

을 실행하면 웹 브라우저에서 로컬 문서를 읽을 수 있다.

## visual studio code 설정

visual studio code > extensions 에서 다음과 같은 것을 다운받는다.

1. Rust
2. Rustfmt
3. Better TOML
4. crates


## 코드 실행

프로젝트를 만들어 코딩을 작성하자

```
$ mkdir rust
$ cd rust
$ mkdir 1_hello_world
$ cd 1_hello_world
$ touch main.rs
```

러스트의 확장자는 `.rs`이다. 이제 main.rs에 아래와 같은 코드를 작성해준다.

**main.rs**

```rust
fn main() {
  println!("Hello, world");
}
```

해당 코드를 입력 한 후 아래와 같은 명령어를 쳐서 실행하자.

```
$ rustc main.rs
$ ./main
```

그러면 Hello World가 실행된다.

rustc를 이용해서 컴파일을 하게 되면, 어셈블리로 변환이 되어 코드가 생성된다. 생성된 코드를 실행하는 방법으로 동작한다.

다음은 기본적인 소스코드를 살펴보도록 하자.

```rust
fn main() {
  
}
```

1. main 함수는 실행 가능한 코든 러스트 프로그램에서 가장 첫 번째로 실행된다. 첫 번째 줄은 매개 변수도 없고 리턴값도 없는 main이라는 이름의 함수를 선언한다. 함수에 매개변수가 필요하면 괄호안에 매개변수를 나열하면 된다.

2. 러스트는 모든 함수에 중괄호로 둘러싸야 한다.

메인 함수 내부를 살펴보자.

```rust
println!("Hello, World");
```

1. 러스트는 들여쓰기를 탭이 아닌, 공백 문자 4개를 이용한다.
2. println! 은 '러스트 매크로' 라고 부르는 것이다. 매크로 대신 함수를 사용했다면 println만 사용했을 것이다. ! 기호를 보면 함수가 아닌 매크로를 호출한 다는 것을 기억해두자.
3. 'Hello, world! 문자열은 println! 매크로의 인수로 전달되어 화면에 출력된다.
4. 각 구문은 세미콜론(;)으로 끝난다. 이 기호는 표현식이 완료되었으며, 다음 표현식이 시작한다는 걸 의미한다.

## 컴파일러 실행과 분리

러스트 프로그램을 실행하려면 러스트 컴파일러로 프로그램을 먼저 컴파일해야 한다. 컴파일을 실행하려면 다음과 같이 rustc 명령에 컴파일할 소스 파일의 이름을 전달하자

```
$ rustc main.rs
```

C/C++에서 사용하는 것과 같이 gcc, clang등의 컴파일러를 이용하는 것과 유사하다. 컴파일이 되면 러스트는 실행 가능한 바이너리 파일을 생성한다.

바이너리 파일은 리눅스, macOS 또는 윈도우 파워셸 에서 ls 명령을 입력해 확인이 가능하다.

```
$ ./main
```

실행하면 'Hello World' 가 출력된다.

러스트는 미리(ahead-of-time) 컴파일하는 언어다. 프로그램을 컴파일해서 생성된 바이너리를 다른 사람에게 전달하면, 그 사람은 러스트를 설치하지 않고도 해당 프로그램을 실행할 수 있다.

누군가에게 .rb, .py, .js 파일을 전달하면 당사자는 루비, 파이썬 혹은 자바스크립트 언어를 자신의 머신에 설치해야 비로소 프로그램을 실행할 수 있다. 이런 동적언어들은 프로그램의 컴파일과 실행을 하나의 명령으로 실행한다.

각 언어의 디자인에 따라 이런 트레이드오프가 존재한다.

rustc를 이용해 간단한 프로그램을 컴파일하는 것은 아무런 문제가 없지만, 프로젝트의 규모가 커질수록 소스 코드를 관리하고 공유하기 위한 다양한 옵션이 필요하므로 Cargo에 대해서 알아보도록 하자.

## 카고 (Cargo)

카고는 러스트 프로그래밍 언어의 패키지 관리자이며 빌드 시스템이다. 대다수의 러스타시안(rustasian = 러스트를 사용하는 개발자들)은 카고를 이용해 러스트 프로젝트를 관리한다. 카고는 코드의 빌드, 라이브러리의 다운로드, 빌드등 대신 처리해준다.

간단한 러스트 프로그램은 의존 라이브러리가 필요하지 않다. 그래서 카고를 이용해 Hello World를 출력하면 코드를 빌드하는 카고의 기능만을 사용하게 된다. 더 복잡한 러스트 프로그램을 작성하게 되면 의존 라이브러리가 필요할 것이고 카고를 이용해 프로젝트를 생성하면 의존성을 추가하기 쉬워진다.

아래의 코드로 카고 설치 유무를 확인하자

```
$ cargo --version
```

화면에 버전 번호가 출력되면 잘 설치가 된 것이다.

### 프로젝트 생성

현재 속해있는 1_Hello_World 폴더와 cargo로 만든 프로젝트를 비교하기위해 다음과 같이 진행한다.

```
$ cd ../
$ cargo new hello_cargo
$ cd hello_cargo
```

`cargo new hello_cargo`는 새로운 디렉토리를 생성한다. 프로젝트의 이름을 `hello_cargo`라고 지정했으므로 카고는 필요한 파일을 프로젝트의 이름과 같은 디렉터리에 생성한다.

`hello_cargo` 디렉토리로 들어가 파일 목록을 살펴보자.

main.rs 파일 보관된 src 폴더 디렉토리와 Cargo.toml 파일을 생성해준 걸 볼 수 있다.

**Cargo.toml**

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["작성자 <이메일>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

이 파일은 TOML(Tom's Obvious, Minimal Language) 형식으로 작성되어 있다. 해당 파일은 카고의 설정파일 중 하나이다.

1. [package]는 패키지의 설정을 관리하기위한 구문들이 시작됨을 의미한다.
2. 다음 4줄은 카고가 프로그램을 컴파일할 때 필요한 이름, 버전 및 작성자, 러스트가 사용할 에디션 등의 설정 정보이다.
3. 카고 프로젝트는 소스코드를 src 디렉터리에 보관한다.
4. 혹시 카고를 이용해 생성하지 않았어도 파일 안에 Cargo.toml을 만들면 된다.

### 빌드와 실행

카고 프로젝트에서 빌드하는 방법은 우리가 아까전에 했던 방법과 조금 다르다. 카고의 명령어를 사용하면 된다.

```
$ cargo build
```

이 명령어를 실행하면 현재 디렉터리가 아니라 target/debug/hello_cargo 경로에 실행 파일이 생성된다. 이 실행 명령은 다음과 같이 실행할 수 있다.

```
$ ./target/debug/hello_cargo
Hello, World
```

아무런 문제가 없이 빌드와 실행이 완료되었다면 Hello, World가 출력된다. cargo build 명령을 실행하면 최상단에 Cargo.lock이 생성되는데 이 파일은 프로젝트에 필요한 의존 패키지의 정확한 버전을 추적하기 위한 파일이다.

위 처럼 실제 경로에서 긁어와 실행하는 건 리소스가 많이 드는 작업이다. 그러므로 아래의 명령어로 쉽게 실행하도록 한다.

```
$ cargo run
```

이번에는 빌드 관련 메시지가 나오지 않았는데, 그 이유는 카고가 코드의 변경점이 없음을 인지하고 빌드하지 않고 바로 실행했기 때문이다. 소스코드를 수정하게되면 바이너리를 실행하기 전에 프로젝트를 다시 빌드한다.

카고는 `cargo check`라는 명령을 지원한다. 이 명령은 코드의 컴파일 여부를 신속하게 검사하지만 실행하지는 않는다.

```
$ cargo check
```

실행 파일을 생성하지 않는 기능이 필요한 이유는 `cargo check` 명령이 실행 파일을 생성하는 과정을 생략하므로 `cargo build`보다 빠르게 실행된다. 그러므로 코드를 작성하는 동안 작업 결과에 오류가 없는지를 계속 확인하려면 `cargo check` 명령이 효율적이기 때문이다. 그래서 러스타시안들은 수시로 `cargo check` 명령을 실행해서 자신들의 코드가 제대로 컴파일되는지를 확인한다. 그리고 실행 파일이 필요하면 그 때 `cargo build`를 해서 뽑아낸다.

- `cargo build`와 `cargo check` 명령을 이용하면 프로젝트 빌드 할 수 있음
- `cargo run` 명령을 이용하면 프로젝트의 빌드와 실행을 한번에 해결할 수 있음
- 카고는 빌드 결과물을 소스와 같은 디렉토리가 아니라 `target/debug` 디렉토리에 따로 저장.

카고를 사용하게되면 운영체제마다 다르게 실행할 필요도 없다.

### 릴리즈 빌드

프로젝트를 디버깅하거나 테스트하는 수준을 끝내면 릴리즈 빌드륾 만들어야 한다.

```
$ cargo build --release
```

이 명령은 `target/debug`가 아닌 `target/release` 경로에 실행 파일을 생성한다. 이 때 실행되는 최적화 덕분에 러스트 코드는 더 빠르게 실행되지만 프로그램을 컴파일하는 시간은 더 길어진다.

더 빨리 자주 컴파일 하기 위한 개발용 프로필과 최종 완성된 프로그램을 사용자에게 제공하기 위해 최대한 빠르게 실행될 수 있도록 컴파일하기 위한 프로필이 별개로 분리된 이유이다.

코드 실행 시간을 벤치마킹해 보려면 `cargo build --release` 명령을 이용해 빌드한 후 `target/release` 경로의 실행 파일 이용해 벤치마킹을 실행하면 된다.

---

# 공부하면서 느꼈던 점

당장 사용하고 있는 Node.js 환경만 보더라도, 실행에 커맨드나 다양한 부분을 Package.json에서 설정할 수 있게 확장의 여지를 두었다. 그 반면에, `Rust`는 `Cargo` 패키지 매니저에서 `run`, `build`, `check`를 강제해놓아, Node.js 처럼 package.json을 들여다보지 않고도 실행과 빌드, 체크를 진행할 수 있다.

이러한 부분이 바로 러스트 생태계가 지향하는 부분이라는 걸 느꼈고, 생각외로 엄청빠르다 (...)